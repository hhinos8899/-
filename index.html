<script>
/* ===== 页面加载后初始化 ===== */
document.addEventListener('DOMContentLoaded', () => {
  initializeGrid();
});

/* ===== 网格初始化（原版不动） ===== */
function initializeGrid() {
  const gridContainer = document.querySelector('.grid-container');
  gridContainer.innerHTML = '';

  // 10列x6行（竖着输入）
  for (let i = 0; i < 10; i++) {
    const column = document.createElement('div');
    column.className = 'column';
    for (let j = 0; j < 6; j++) {
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.dataset.index = (i * 6 + j).toString();

      const mainResult = document.createElement('div');
      mainResult.className = 'main-result';
      cell.appendChild(mainResult);

      const predictionText = document.createElement('div');
      predictionText.className = 'prediction-text';
      cell.appendChild(predictionText);

      column.appendChild(cell);
    }
    gridContainer.appendChild(column);
  }

  // 结果
  window.results = [];

  // ✅关键：预测记录表（预测写进去就“封存”，不会被后续输入清掉）
  window.predMap = {}; // key: cellIndex(0-59)  value: "预测:B/P"

  updateCounter();
  updateGrid(); // 首次渲染
}

/* ===== 按钮绑定（原版不动） ===== */
document.getElementById('btn-b').addEventListener('click', () => addResult('B'));
document.getElementById('btn-p').addEventListener('click', () => addResult('P'));
document.getElementById('btn-clear').addEventListener('click', clearAll);
document.getElementById('btn-back').addEventListener('click', removeLast);

/* ===== 预测触发点（你的规则：7~58那18个） ===== */
const predictionRounds = [7,10,13,16,19,22,25,28,31,34,37,40,43,46,49,52,55,58];

/* ===== 18套规则（和你之前那套一致：只看最近两把BP） ===== */
const RULES = [
  ({a,b})=>a==="P"&&b==="B"?"B":a==="P"&&b==="P"?"P":a==="B"&&b==="P"?"B":"P",
  ({a,b})=>a==="B"&&b==="B"?"B":a==="B"&&b==="P"?"P":a==="P"&&b==="P"?"B":"P",
  ({a,b})=>a==="P"&&b==="P"?"P":a==="P"&&b==="B"?"B":a==="B"&&b==="P"?"B":"P",
  ({a,b})=>a==="P"&&b==="B"?"B":a==="P"&&b==="P"?"P":a==="B"&&b==="P"?"B":"P",
  ({a,b})=>a==="B"&&b==="P"?"P":a==="B"&&b==="B"?"B":a==="P"&&b==="P"?"B":"P",
  ({a,b})=>a==="P"&&b==="P"?"P":a==="P"&&b==="B"?"B":a==="B"&&b==="P"?"B":"P",
  ({a,b})=>a==="P"&&b==="B"?"B":a==="P"&&b==="P"?"P":a==="B"&&b==="P"?"B":"P",
  ({a,b})=>a===b?"B":"P",
  ({a,b})=>a==="P"&&b==="B"?"B":a==="P"&&b==="P"?"P":a==="B"&&b==="P"?"B":"P",
  ({a,b})=>a==="B"&&b==="B"?"B":a==="B"&&b==="P"?"P":a==="P"&&b==="P"?"B":"P",
  ({a,b})=>a==="P"&&b==="P"?"P":a==="P"&&b==="B"?"B":a==="B"&&b==="P"?"B":"P",
  ({a,b})=>a==="P"&&b==="B"?"B":a==="P"&&b==="P"?"P":a==="B"&&b==="P"?"B":"P",
  ({a,b})=>a===b?"B":"P",
  ({a,b})=>a===b?"P":"B",
  ({a,b})=>a===b?"B":"P",
  ({a,b})=>a===b?"P":"B",
  ({a,b})=>a===b?"P":"B",
  ({a,b})=>a===b?"B":"P",
];

/* ===== 添加结果 ===== */
function addResult(type) {
  if (window.results.length >= 60) return;

  window.results.push(type);

  updateGrid();
  maybeWritePrediction(); // ✅写预测（写进predMap，永不被清）
}

/* ===== 更新网格：主结果照画；预测永远从 predMap 回填（不会丢） ===== */
function updateGrid() {
  const cells = document.querySelectorAll('.cell');
  cells.forEach(cell => {
    const index = parseInt(cell.dataset.index, 10);
    const mainResult = cell.querySelector('.main-result');
    const predictionText = cell.querySelector('.prediction-text');

    if (index < window.results.length) {
      cell.className = 'cell ' + window.results[index];
      mainResult.textContent = window.results[index];
    } else {
      cell.className = 'cell';
      mainResult.textContent = '';
    }

    // ✅关键：预测永远从 predMap 渲染（历史预测不会被刷新删掉）
    predictionText.textContent = window.predMap[index] || '';
  });

  updateCounter();
}

/* ===== 计数器 ===== */
function updateCounter() {
  document.getElementById('input-count').textContent = window.results.length;
}

/* ===== 清除 ===== */
function clearAll() {
  window.results = [];
  window.predMap = {};     // ✅清除时才清空所有预测
  updateGrid();
}

/* ===== 退格 ===== */
function removeLast() {
  if (window.results.length === 0) return;

  window.results.pop();

  // ✅把“当前以及后面”的预测都删掉（因为状态回退了）
  for (let i = window.results.length; i < 60; i++) {
    delete window.predMap[i];
  }

  updateGrid();
  maybeWritePrediction(); // 回退后如果该格需要预测，重新写（写进predMap）
}

/* ===== 最近两把BP ===== */
function last2BP() {
  const bp = window.results.filter(x => x === 'B' || x === 'P');
  if (bp.length < 2) return null;
  return bp.slice(-2);
}

/* ===== ✅你的规则：输入满6把后，遇到触发点才写预测；预测写进predMap并永久保留 ===== */
function maybeWritePrediction() {
  // 必须先输入6把才开始预测
  if (window.results.length < 6) return;

  const nextRound = window.results.length + 1; // 下一把的局数
  const ruleIndex = predictionRounds.indexOf(nextRound);
  if (ruleIndex < 0) return;

  const l2 = last2BP();
  if (!l2) return;

  const p = RULES[ruleIndex]({ a: l2[0], b: l2[1] });
  const cellIndex = window.results.length; // 预测写在“下一格”(空格)

  // ✅如果这个格子已经有预测（历史），不强行覆盖；没有才写入
  if (!window.predMap[cellIndex]) {
    window.predMap[cellIndex] = `预测:${p}`;
    updateGrid();
  }
}
</script>

